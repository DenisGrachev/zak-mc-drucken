
;org 33000

;halt


;loop
;call Inkey
;ld a,l
;cp 'r'
;jr nz,loop

;loop2
;call GetKey
;ld a,l
;cp 'r'
;jr nz,loop2

;ret


;defb 'r'
; uint in_Inkey(void)
; 09.2005 aralbrec

; Read current state of keyboard but only return
; keypress if a single key is pressed.

; exit : carry set and HL = 0 for no keys registered
;        else HL = ASCII character code
; uses : AF,BC,DE,HL

Inkey

   ld de,0
   ld bc,#fefe
   in a,(c)
   or $e1
   cp $ff
   jr nz, keyhitA

   ld e,5
   ld b,$fd
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,10
   ld b,$fb
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,15
   ld b,$f7
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,20
   ld b,$ef
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,25
   ld b,$df
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,30
   ld b,$bf
   in a,(c)
   or $e0
   cp $ff
   jr nz, keyhitA

   ld e,35
   ld b,$7f
   in a,(c)
   or $e2
   cp $ff
   ld c,a
   jr nz, keyhitB

nokey

   ld hl,0
   scf
   ret

keyhitA

   ld c,a

   ld a,b
   cpl
   or $81
   in a,($fe)
   or $e0
   cp $ff
   jr nz, nokey

   ld a,$7f
   in a,($fe)
   or $e2
   cp $ff
   jr nz, nokey

keyhitB

   ld b,0
   ld hl,rowtbl-$e0
   add hl,bc
   ld a,(hl)
   cp 5
   jr nc, nokey
   add a,e
   ld e,a

   ld hl,keytranstbl
   add hl,de

   ld a,$fe
   in a,($fe)
   and $01
   jr nz, nocaps
   ld e,40
   add hl,de

nocaps

   ld a,$7f
   in a,($fe)
   and $02
   jr nz, nosym
   ld e,80
   add hl,de

nosym

   ld l,(hl)
   ld h,0
   ret

rowtbl
   defb 255,255,255,255,255,255,255
   defb 255,255,255,255,255,255,255,255
   defb 4,255,255,255,255,255,255
   defb 255,3,255,255,255,2,255,1
   defb 0,255

keytranstbl
   defb 255,'z','x','c','v'      ; CAPS SHIFT, Z, X, C, V
   defb 'a','s','d','f','g'      ; A, S, D, F, G
   defb 'q','w','e','r','t'      ; Q, W, E, R, T
   defb '1','2','3','4','5'      ; 1, 2, 3, 4, 5
   defb '0','9','8','7','6'      ; 0, 9, 8, 7, 6
   defb 'p','o','i','u','y'      ; P, O, I, U, Y
   defb 13,'l','k','j','h'       ; ENTER, L, K, J, H
   defb ' ',255,'m','n','b'      ; SPACE, SYM SHIFT, M, N, B

   ; the following are CAPS SHIFTed

   defb 255,'Z','X','C','V'      ; CAPS SHIFT, Z, X, C, V
   defb 'A','S','D','F','G'      ; A, S, D, F, G
   defb 'Q','W','E','R','T'      ; Q, W, E, R, T
   defb 7,0,128,129,8            ; 1, 2, 3, 4, 5
   defb 12,8,9,11,10             ; 0, 9, 8, 7, 6
   defb 'P','O','I','U','Y'      ; P, O, I, U, Y
   defb 13,'L','K','J','H'       ; ENTER, L, K, J, H
   defb ' ',255,'M','N','B'      ; SPACE, SYM SHIFT, M, N, B

   ; the following are SYM SHIFTed

   defb 255,':',96,'?','/'       ; CAPS SHIFT, Z, X, C, V
   defb '~','|',92,'{','}'       ; A, S, D, F, G
   defb 131,132,133,'<','>'      ; Q, W, E, R, T
   defb '!','@','#','$','%'      ; 1, 2, 3, 4, 5
   defb '_',')','(',39,'&'       ; 0, 9, 8, 7, 6
   defb 34,';',130,']','['       ; P, O, I, U, Y
   defb 13,'=','+','-','^'       ; ENTER, L, K, J, H
   defb ' ',255,'.',',','*'      ; SPACE, SYM SHIFT, M, N, B

   ; the following are CAPS SHIFTed and SYM SHIFTed ("CTRL" key)

   defb 255,26,24,3,22           ; CAPS SHIFT, Z, X, C, V
   defb 1,19,4,6,7               ; A, S, D, F, G
   defb 17,23,5,18,20            ; Q, W, E, R, T
   defb 27,28,29,30,31           ; 1, 2, 3, 4, 5
   defb 127,255,134,'`',135      ; 0, 9, 8, 7, 6
   defb 16,15,9,21,25            ; P, O, I, U, Y
   defb 13,12,11,10,8            ; ENTER, L, K, J, H
   defb ' ',255,13,14,2          ; SPACE, SYM SHIFT, M, N, B

; uint in_GetKey(void)
; 09.2005 aralbrec

; Scans the keyboard and returns an ascii code representing a
; single keypress.  Operates as a state machine.  First
; it debounces a key by ignoring it until a minimum time
; "_in_KeyDebounce" (byte) has passed.  The key will be registered
; and then it will wait until the key has been pressed for a period
; "_in_KeyStartRepeat" (byte).  The key will again be registered and
; then repeated thereafter with period "_in_KeyRepeatPeriod" (byte).
; If more than one key is pressed, no key is registered and the
; state machine returns to the debounce state.  Time intervals
; depend on how often GetKey is called.

;XLIB in_GetKey
;LIB in_Inkey, in_GetKeyReset
;XREF _in_KeyDebounce, _in_KeyStartRepeat, _in_KeyRepeatPeriod
;XREF _in_KbdState

; exit : carry = no key registered (and HL=0)
;        else HL = ascii code of key pressed
; uses : AF,BC,DE,HL

GetKey

   call Inkey              ; hl = ascii code & carry if no key
   jp c, GetKeyReset

   ld a,(KbdState)
   dec a
   jr nz, nokeygk

   ld a,(KbdState + 1)
   dec a
   jp m, debounce
   jp z, startrepeat

repeat

   ld a,(KeyRepeatPeriod)
   ld (KbdState),a
   ret

debounce

   ld a,(KeyStartRepeat)
   ld e,a
   ld d,1
   ld (KbdState),de
   ret

startrepeat

   ld a,(KeyRepeatPeriod)
   ld e,a
   ld d,2
   ld (KbdState),de
   ret

nokeygk

   ld (KbdState),a
   ld hl,0
   scf
   ret

; void in_GetKeyReset(void)
; 09.2005 aralbrec

;XLIB in_GetKeyReset
;XREF _in_KeyDebounce, _in_KbdState

GetKeyReset
   ld a,(KeyDebounce)
   ld e,a
   ld d,0
   ld (KbdState),de
   ret

;
; GLOBAL VARS
;
;1,2,4 - good
;1.2.3. - good

;2 3 1 - default


   IFNDEF DEBOUNCER
;3;3;1
KeyDebounce
   defb 2
KeyStartRepeat
   defb 2
KeyRepeatPeriod
   defb 1

   ELSE

   ;3;3;1
KeyDebounce
   defb 3
KeyStartRepeat
   defb 3
KeyRepeatPeriod
   defb 2

   ENDIF

; LOCAL VARS

KbdState
   defb 0                     ; 0 = debounce, 1 = start repeat, 2 = repeat
   block 32,0